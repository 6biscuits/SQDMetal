from qiskit_metal import draw
from qiskit_metal.toolbox_python.attr_dict import Dict
from qiskit_metal.qlibrary.core import QComponent
import numpy as np
import shapely

class FluxLineTPin(QComponent):
    """Create a flux line inlet in the form of a T which splits the current equally across 2 branches. Intended for an Xmon, but
    it can be used with any JJ SQUID loop.

    Inherits QComponent class.

    The Dolan Bridge consists of a T-Section followed by a Fork Section.

    Dolan Bridge Josephson Junction Metal Geometry (no Ground Cutout):
        * width - Width of the flux line T junction
        * pin_dist - Distance from the target pin (e.g. a section of an Xmon)
        * trace_width - CPW width of the flux line inlet (it is used for the T section)
        * trace_gap   - CPW gap of the flux line inlet (it is used for the T section)

    As usual, the positioning can be done dynamically as a vector given by the supplied parameters: (pos_x,pos_y) to (end_x,end_y)
        
    Pins:
        There are two pins:
            'a' - joins onto the flux-line inlet.
            't' - a point that is in line with the target pin - useful in aligning/placing SQUID loops or junctions

    Sketch:
        Below is a sketch of the Josephson Junction Shadow Evaporation masking template (there is no ground cut-out)
        ::

            @@@@@@@@@@@@@#####@      x = Target pin location
            @@@@@@@@@@@@@#####@      @ = Ground plane
            @@@@@@@@@@@@@##x##@      # = Reference target pin (in this case, it's aligned with pin_align_right=True)
            @@@@@@@@@@@@@     @D     W = width
            @@@@@@@@@@@@@  C  @D     S = trace_width
            @ _____________t_ @D     G = trace_gap
            @|______   ______|@      D = pin_dist
            @    G  |S|       @      a = Location of pin to which the flux line CPW attaches
            @@@@@@@@@a@@@@@@@@@      t = Location of pin that faces the target pin on the flux T junction
             W...............W       C = Ground cut-out generated by this structure to meet up with the reference target pin. Also,
                                         the usual location of the SQUID loop...
                   
    .. image::
        Cap3Interdigital.png

    .. meta::
        T-shaped Flux Line

    Default Options:
        * width='50um'
        * pin_dist='30um'
        * trace_width='20um'
        * trace_gap='20um'
    """

    default_options = Dict(ref_comp='', ref_pin='',
                           width='50um',
                           pin_dist='30um',
                           trace_width='20um',
                           trace_gap='20um',
                           pin_align_right=True)

    def make(self):
        """This is executed by the user to generate the qgeometry for the
        component."""
        p = self.p
        #########################################################

        jointPin = self._design.components[self.options.ref_comp].pins[self.options.ref_pin]
        ptJoint = jointPin['middle']
        normal = -jointPin['normal']
        rot_angle = np.arctan2(normal[1], normal[0])
        targ_trace_width = jointPin['width']

        #The T-Section and Stem
        pad_T = [
                (0, p.width*0.5),
                (-p.trace_width, p.width*0.5),
                (-p.trace_width, p.trace_width*0.5),
                (-p.trace_width-p.trace_gap, p.trace_width*0.5),
                (-p.trace_width-p.trace_gap, -p.trace_width*0.5),
                (-p.trace_width, -p.trace_width*0.5),
                (-p.trace_width, -p.width*0.5),
                (0, -p.width*0.5)]
        pad_T = np.array(pad_T)
        
        pad_gap = [
                  (p.trace_gap, p.width*0.5),
                  (-p.trace_width-p.trace_gap, p.width*0.5),
                  (-p.trace_width-p.trace_gap, -p.width*0.5),
                  (p.pin_dist, -p.width*0.5),
                  (p.pin_dist, -p.width*0.5+targ_trace_width),
                  (p.trace_gap, -p.width*0.5+targ_trace_width)]
        pad_gap = np.array(pad_gap)

        if p.pin_align_right:
            pad_T[:,1] += (p.width-targ_trace_width)*0.5
            pad_gap[:,1] += (p.width-targ_trace_width)*0.5
        else:
            pad_T[:,1] += (-p.width+targ_trace_width)*0.5
            pad_gap[:,1] *= -1
            pad_gap[:,1] += (-p.width+targ_trace_width)*0.5
        pad_T[:,0] -= p.pin_dist
        pad_gap[:,0] -= p.pin_dist

        pin = pad_T[3:5]
        if p.pin_align_right:
            pin2 = [pad_T[-1], pad_T[-1]+np.array([0,targ_trace_width])]
        else:
            pin2 = [pad_T[0]-np.array([0,targ_trace_width]), pad_T[0]]

        pad_T = shapely.Polygon(pad_T)
        pad_gap = shapely.Polygon(pad_gap)
        pin = shapely.LineString(pin)
        pin2 = shapely.LineString(pin2)

        polys = [pad_T, pad_gap, pin, pin2]
        polys = draw.rotate(polys, rot_angle, origin=(0, 0), use_radians=True)
        polys = draw.translate(polys, *ptJoint)
        [pad_T, pad_gap, pin, pin2] = polys


        # Adds the object to the qgeometry table
        self.add_qgeometry('poly',
                           dict(flTjunc=pad_T),
                           layer=p.layer)

        #subtracts out ground plane on the layer it's on
        self.add_qgeometry('poly',
                           dict(padGap=pad_gap),
                           subtract=True,
                           layer=p.layer)

        # Generates its own pins
        self.add_pin('a', pin.coords[::-1], width=p.trace_width)
        self.add_pin('t', pin2.coords[::-1], width=targ_trace_width)
